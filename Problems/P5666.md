#  [[CSP-S2019] 树的重心](https://www.luogu.com.cn/problem/P5666)

## 题意

>   ## 题目描述
>
>   小简单正在学习离散数学，今天的内容是图论基础，在课上他做了如下两条笔记：
>
>   1.  一个大小为 n*n* 的树由 n*n* 个结点与 n−1*n*−1 条无向边构成，且满足任意两个结点间**有且仅有**一条简单路径。在树中删去一个结点及与它关联的边，树将分裂为若干个子树；而在树中删去一条边（保留关联结点，下同），树将分裂为**恰好**两个子树。
>   2.  对于一个大小为 n*n* 的树与任意一个树中结点 c*c*，称 c*c* 是该树的**重心**当且仅当在树中删去 c*c* 及与它关联的边后，分裂出的所有子树的大小均**不超过** ⌊n2⌋⌊2*n*⌋（其中 ⌊x⌋⌊*x*⌋ 是下取整函数）。对于包含至少一个结点的树，它的重心只可能有 1 或 2 个。
>
>   课后老师给出了一个大小为 n*n* 的树 S*S*，树中结点从 1∼n1∼*n* 编号。小简单的课后作业是求出 S*S* 单独删去每条边后，分裂出的两个子树的重心编号和之和。即：
>
>   ∑(u,v)∈E(∑1≤x≤n且x号点是Su′的重心x+∑1≤y≤n且y号点是Sv′的重心y)(*u*,*v*)∈*E*∑⎝⎜⎜⎛且*x*号点是*S**u*′的重心1≤*x*≤*n*∑*x*+且*y*号点是*S**v*′的重心1≤*y*≤*n*∑*y*⎠⎟⎟⎞
>
>   上式中，E*E* 表示树 S*S* 的边集，(u,v)(*u*,*v*) 表示一条连接 u*u* 号点和 v*v* 号点的边。Su′*S**u*′ 与 Sv′*S**v*′ 分别表示树 S*S* 删去边 (u,v)(*u*,*v*) 后，u*u* 号点与 v*v* 号点所在的被分裂出的子树。
>
>   小简单觉得作业并不简单，只好向你求助，请你教教他。
>
>   ## 输入格式
>
>   **本题包含多组测试数据**
>
>   第一行一个整数 T*T* 表示数据组数。
>
>   接下来依次给出每组输入数据，对于每组数据：
>
>   第一行一个整数 n*n* 表示树 S*S* 的大小。
>
>   接下来 n−1*n*−1 行，每行两个以空格分隔的整数 ui*u**i*，vi*v**i*，表示树中的一条边 (ui,vi)(*u**i*,*v**i*)。
>
>   ## 输出格式
>
>   共 T*T* 行，每行一个整数，第 i*i* 行的整数表示：第 i*i* 组数据给出的树单独删去每条边后，分裂出的两个子树的重心编号和之和。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   2
>   5
>   1 2
>   2 3
>   2 4
>   3 5
>   7
>   1 2
>   1 3
>   1 4
>   3 5
>   3 6
>   6 7
>   ```
>
>   **输出 #1**复制
>
>   ```
>   32
>   56
>   ```
>
>   ## 说明/提示
>
>   【样例 1 解释】
>
>   对于第一组数据：
>
>   删去边 (1,2)(1,2)，1 号点所在子树重心编号为 {1}{1}，2 号点所在子树重心编号为 {2,3}{2,3}。
>
>   删去边 (2,3)(2,3)，2 号点所在子树重心编号为 {2}{2}，3 号点所在子树重心编号为 {3,5}{3,5}。
>
>   删去边 (2,4)(2,4)，2 号点所在子树重心编号为 {2,3}{2,3}，4 号点所在子树重心编号为 {4}{4}。
>
>   删去边 (3,5)(3,5)，3 号点所在子树重心编号为 {2}{2}，5 号点所在子树重心编号为 {5}{5}。
>
>   因此答案为 1+2+3+2+3+5+2+3+4+2+5=321+2+3+2+3+5+2+3+4+2+5=32。
>
>   【数据范围】
>
>   | 测试点编号 | n=*n*=       | 特殊性质 |
>   | :--------- | :----------- | :------- |
>   | 1∼21∼2     | 77           | 无       |
>   | 3∼53∼5     | 199199       | 无       |
>   | 6∼86∼8     | 19991999     | 无       |
>   | 9∼119∼11   | 4999149991   | A        |
>   | 12∼1512∼15 | 262143262143 | B        |
>   | 1616       | 9999599995   | 无       |
>   | 17∼1817∼18 | 199995199995 | 无       |
>   | 19∼2019∼20 | 299995299995 | 无       |
>
>   表中特殊性质一栏，两个变量的含义为存在一个 1∼n1∼*n* 的排列 pi(1≤i≤n)*p**i*(1≤*i*≤*n*)，使得：
>
>   -   A：树的形态是一条链。即 ∀1≤i<n∀1≤*i*<*n*，存在一条边 (pi,pi+1)(*p**i*,*p**i*+1)。
>   -   B：树的形态是一个完美二叉树。即 ∀1≤i≤n−12∀1≤*i*≤2*n*−1 ，存在两条边 (pi,p2i)(*p**i*,*p*2*i*) 与 (pi,p2i+1)(*p**i*,*p*2*i*+1)。
>
>   对于所有测试点：1≤T≤5,1≤ui,vi≤n1≤*T*≤5,1≤*u**i*,*v**i*≤*n*。保证给出的图是一个树。

## 题解

**推导思路示例：**

>   考虑重心的出现位置。有结论：
>
>   >   对于一个节点 uu ，如果 n − siz[u] ≤ ⌊n/2⌋ ，且 u 本身并非重心，那么重心一定在 u 的重儿子里面。
>
>   推论：
>
>   >   （此处的 u 依然满足 n − siz[u] ≤ ⌊n/2⌋ ）
>   >
>   >   1.  前置：显然 u 只有一个重儿子。
>   >   2.  重心的可能位置只有两种，要么是 u 要么在 u 的重子树里面。
>   >   3.  如果 u 是满足这个条件且 dep[u] 最大的点，那么根据上面的结论， u 就是重心，且 fa[u] 也有可能是重心。
>
>
>   因此，重心一定在 root 向下的重链上，而且重链上自上往下，节点的 siz 递减。再结合数据范围得到合理猜测：复杂度  O(nlog⁡n) .
>
>   那么就可以考虑在重链上倍增。令 `f[i][x] `表示以 rt 为根，节点 x 沿着重链往下走 2i 步达到的节点。这样，求重心的时候就类似 LCA 一样，逆序枚举 ii 往下跳就好了。
>
>   然后类似换根DP，二次扫描维护 ff 数组和重儿子即可。
>
>   时间复杂度是 O(nlog⁡n) .
>
>   作者：RingweEH
>   链接：https://www.acwing.com/solution/content/26465/
>   来源：AcWing
>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



Luogu 和网络上各类题解及其代码都特别麻烦。。。

**本质上就是枚举删哪条边，同时利用倍增快速找到重心，以及利用换根降低计算复杂度。**

细节见代码

```c++
#include <bits/stdc++.h>
using namespace std;

using LL = long long;
const int N = 3e5 + 10, M = N << 1, K = 20; // 2^19

int t, n;
int h[N], e[M], ne[M], idx;
int son[N][K], sz[N], pa[N], w[N][2];
LL res;

void init() {
    memset(h, -1, sizeof h);
    idx = 0;
    res = 0;
    memset(sz, 0, sizeof sz);   // sz[0] = 0;
    memset(son, 0, sizeof son);
    memset(w, 0, sizeof w);
    memset(pa, 0, sizeof pa);
}

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void update_st(int u) {
    for (int k = 1; k < K; ++ k )
        son[u][k] = son[son[u][k - 1]][k - 1];
}

void calc(int u) {
    int x = u;
    for (int k = K - 1; k >= 0; -- k )
        if (son[x][k] && sz[son[x][k]] * 2 >= sz[u])
            x = son[x][k];
    // 如果某子树大小刚好是根树的一半 则子树及子树的父节点都是重心
    if (sz[x] * 2 == sz[u])
        res += (LL)pa[x];
    res += (LL)x;
}

void dfs_d(int u, int fa) {
    sz[u] = 1, pa[u] = fa;
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (j != fa) {
            dfs_d(j, u);
            
            sz[u] += sz[j];
            // 考虑断开某条边后 换根后需要对是否是重链做判读 预处理
            // 重儿子和次重儿子
            if (sz[j] >= sz[w[u][0]])
                w[u][1] = w[u][0], w[u][0] = j;
            else if (sz[j] >= sz[w[u][1]])
                w[u][1] = j;
        }
    }
    
    son[u][0] = w[u][0];
    update_st(u);
}

void dfs_u(int u, int fa) {
    // t1: 在换根过程中 sz[u] 会变，使用临时变量 t1 记录
    // t2: 换根过程中 u 的父节点会作为 u 的儿子，会修改 pa[fa]，故使用临时变量记录
    int t1 = sz[u], t2 = pa[fa];
    pa[fa] = u;
    for (int i = h[u]; ~i; i = ne[i]) {
        int j = e[i];
        if (j != fa) {
            // 1. 计算 j 作为根的树
            calc(j);
 
            // 2. 计算 u 作为根的树
            //   2.1 先在向下的方向找个最大的
            son[u][0] = (j == w[u][0] ? w[u][1] : w[u][0]);
            //   2.2 向上的方向继续更新
            if (sz[son[u][0]] < n - t1)
                son[u][0] = pa[u];
            update_st(u);
            sz[u] = n - sz[j];
            calc(u);

            // 3. 递归
            dfs_u(j, u);
        }
    }
    sz[u] = t1, pa[fa] = t2;
    son[u][0] = w[u][0];
    update_st(u);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    
    cin >> t;
    while (t -- ) {
        init();
        
        cin >> n;
        for (int i = 0; i < n - 1; ++ i ) {
            int a, b;
            cin >> a >> b;
            add(a, b), add(b, a);
        }
        
        // 0 instead of -1
        dfs_d(1, 0);
        dfs_u(1, 0);
        
        cout << res << endl;
    }
    return 0;
}
```



```python3

```

