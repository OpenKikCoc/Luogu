#  [【XR-3】核心城市](https://www.luogu.com.cn/problem/P5536)

## 题意

>   ## 题目描述
>
>   X 国有 n*n* 座城市，n−1*n*−1 条长度为 11 的道路，每条道路连接两座城市，且任意两座城市都能通过若干条道路相互到达，显然，城市和道路形成了一棵树。
>
>   X 国国王决定将 k*k* 座城市钦定为 X 国的核心城市，这 k*k* 座城市需满足以下两个条件：
>
>   1.  这 k*k* 座城市可以通过道路，在不经过其他城市的情况下两两相互到达。
>   2.  定义某个非核心城市与这 k*k* 座核心城市的距离为，这座城市与 k*k* 座核心城市的距离的最小值。那么所有非核心城市中，与核心城市的距离最大的城市，其与核心城市的距离最小。你需要求出这个最小值。
>
>   ## 输入格式
>
>   第一行 22 个正整数 n,k*n*,*k*。
>
>   接下来 n−1*n*−1 行，每行 22 个正整数 u,v*u*,*v*，表示第 u*u* 座城市与第 v*v* 座城市之间有一条长度为 11 的道路。
>
>   **数据范围：**
>
>   -   1≤k<n≤1051≤*k*<*n*≤105。
>   -   1≤u,v≤n,u≠v1≤*u*,*v*≤*n*,*u*=*v*，保证城市与道路形成一棵树。
>
>   ## 输出格式
>
>   一行一个整数，表示答案。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   6 3
>   1 2
>   2 3
>   2 4
>   1 5
>   5 6
>   ```
>
>   **输出 #1**复制
>
>   ```
>   1
>   ```
>
>   ## 说明/提示
>
>   【样例说明】
>
>   钦定 1,2,51,2,5 这 33 座城市为核心城市，这样 3,4,63,4,6 另外 33 座非核心城市与核心城市的距离均为 11，因此答案为 11。

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

// 拓扑的方案显然就可做
// 题解区很多用树直径的做法 TODO

const int N = 1e5 + 10, M = N << 1;

int n, k;
int h[N], e[M], ne[M], idx;
int c[N], d[N], q[N];

void init() {
    memset(h, -1, sizeof h);
    idx = 0;
}

void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int main() {
    init();

    cin >> n >> k;
    
    for (int i = 0; i < n - 1; ++ i ) {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
        c[a] ++ , c[b] ++ ;
    }
    
    int hh = 0, tt = -1;
    for (int i = 1; i <= n; ++ i )
        if (c[i] == 1)  // 叶子节点
            q[ ++ tt] = i, d[i] = 1;
    
    int cnt = n - k;
    while (hh <= tt) {
        int t = q[hh ++ ];
        cnt -- ;
        if (!cnt) {
            cout << d[t] << endl;
            return 0;
        }

        for (int i = h[t]; ~i; i = ne[i]) {
            int j = e[i];
            if ( -- c[j] == 1)  // 1
                d[j] = d[t] + 1, q[ ++ tt] = j;
        }
    }
    return 0;
}
```



```python3

```

