#  [Function](https://www.luogu.com.cn/problem/P1464)

## 题意

>   ## 题目描述
>
>   对于一个递归函数w(a,b,c)*w*(*a*,*b*,*c*)
>
>   -   如果a≤0*a*≤0 or b≤0*b*≤0 or c≤0*c*≤0就返回值11.
>   -   如果a>20*a*>20 or b>20*b*>20 or c>20*c*>20就返回w(20,20,20)*w*(20,20,20)
>   -   如果a<b*a*<*b*并且b<c*b*<*c* 就返回w(a,b,c−1)+w(a,b−1,c−1)−w(a,b−1,c)*w*(*a*,*b*,*c*−1)+*w*(*a*,*b*−1,*c*−1)−*w*(*a*,*b*−1,*c*)
>   -   其它的情况就返回w(a−1,b,c)+w(a−1,b−1,c)+w(a−1,b,c−1)−w(a−1,b−1,c−1)*w*(*a*−1,*b*,*c*)+*w*(*a*−1,*b*−1,*c*)+*w*(*a*−1,*b*,*c*−1)−*w*(*a*−1,*b*−1,*c*−1)
>
>   这是个简单的递归函数，但实现起来可能会有些问题。当a,b,c*a*,*b*,*c*均为15时，调用的次数将非常的多。你要想个办法才行.
>
>   >   absi2011 : 比如 w(30,−1,0)*w*(30,−1,0)既满足条件1又满足条件2
>   >   这种时候我们就按最上面的条件来算
>   >   所以答案为1
>
>   ## 输入格式
>
>   会有若干行。
>
>   并以−1,−1,−1−1,−1,−1结束。
>
>   保证输入的数在[−9223372036854775808,9223372036854775807][−9223372036854775808,9223372036854775807]之间，并且是整数。
>
>   ## 输出格式
>
>   输出若干行，每一行格式：
>
>   ```
>   w(a, b, c) = ans
>   ```
>
>   注意空格。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   1 1 1
>   2 2 2
>   -1 -1 -1
>   ```
>
>   **输出 #1**复制
>
>   ```
>   w(1, 1, 1) = 2
>   w(2, 2, 2) = 4
>   ```
>
>   ## 说明/提示
>
>   记忆化搜索

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

using LL = long long;
using TIII = tuple<LL, LL, LL>;

LL a, b, c;

map<TIII, LL> mem;

LL w(int a, int b, int c) {
    if (a <= 0 || b <= 0 || c <= 0)
        return 1;
    if (a > 20 || b > 20 || c > 20)
        return w(20, 20, 20);
    
    LL & t = mem[{a, b, c}];
    if (t)
        return t;
    
    if (a < b && b < c)
        return t =
            w(a, b, c - 1) + 
            w(a, b - 1, c - 1) - 
            w(a, b - 1, c);
    
    return t = 
        w(a - 1, b, c) + 
        w(a - 1, b - 1, c) + 
        w(a - 1, b, c - 1) - 
        w(a - 1, b - 1, c - 1);
}

int main() {
    while (cin >> a >> b >> c) {
        if (a == -1 && b == -1 && c == -1)
            break;
        
        printf("w(%lld, %lld, %lld) = %lld\n",
            a, b, c, w(a, b, c));
    }
    return 0;
}
```



```python3

```

