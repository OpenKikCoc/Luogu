#  [安全系统](https://www.luogu.com.cn/problem/P2638)

## 题意

>   ## 题目描述
>
>   特斯拉公司的六位密码被轻松破解后，引发了人们对电动车的安全性能的怀疑。李华听闻后，自己设计了一套密码：假设安全系统中有n个储存区，每个储存区最多能存储存2个种类不同的信号（可以不储存任何信号）。有0和1这两种信号，其中0有a个，1有b个，单独一个0或1算一个信号。现要将这些信号储存在储存区中，0和1可以不用全部储存，一种不同的储存方案经过李华处理后就将是一串不同的密码。现在给出n，a，b，求可能的不同储存方案的个数。
>
>   ## 输入格式
>
>   第一行：共3个整数，n，a，b。
>
>   a,b≤50*a*,*b*≤50，n+a≤50*n*+*a*≤50，n+b≤50*n*+*b*≤50
>
>   ## 输出格式
>
>   第一行：一个整数，表示方案个数。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   2 1 1
>   ```
>
>   **输出 #1**复制
>
>   ```
>   9
>   ```
>
>   ## 说明/提示
>
>   储存区1 储存区2
>
>   ① NULL NULL
>
>   ② 0 NULL
>
>   ③ 1 NULL
>
>   ④ NULL 0
>
>   ⑤ NULL 1
>
>   ⑥ 0 1 NULL
>
>   ⑦ NULL 0 1
>
>   ⑧ 1 0
>
>   ⑨ 0 1

## 题解

题意有坑。。。

```c++
#include <bits/stdc++.h>
using namespace std;

using ULL = unsigned long long;
const int N = 55;

// 关键在于对题意的理解：
//      按照题解区的思路，每个盒子只是限定了放入其中的球的种类，
//      【并不限定放入其中的单个颜色的球的数量】
// 在此基础上，枚举在 n 个盒子中分别放入 i, j 个两种种类的球
// 【易知两种球的放入情况相互独立，所以可以分别求 n 个盒子放入 x 个球的方案相乘】
// 考虑 n 个盒子放入 x 个球，且有些盒子可以不放球：
//      添加 n 个球变为 n+x，随后使用 n-1 个隔板分隔 n+x 个球的 n+x-1 个间隙
//      则隔板之间的球的数量即为(添加n个球之后的)每个盒子的球数量
//          方案数 ==> C[n+x-1, n-1]
//      每个盒子分别-1即得到原情况的方案，方案数不变

int n, a, b;
ULL C[N][N];

void init() {
    for (int i = 0; i < N; ++ i )
        for (int j = 0; j <= i; ++ j )
            if (!j)
                C[i][j] = 1;
            else
                C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
}

int main() {
    init();
    
    cin >> n >> a >> b;
    
    ULL res = 0;
    for (int i = 0; i <= a; ++ i )
        for (int j = 0; j <= b; ++ j )
            res += C[n + i - 1][n - 1] * C[n + j - 1][n - 1];
    cout << res << endl;
    
    return 0;
}
```



```python3

```

