#  [邦邦的大合唱站队](https://www.luogu.com.cn/problem/P3694)

## 题意

>   ## 题目背景
>
>   BanG Dream!里的所有偶像乐队要一起大合唱，不过在排队上出了一些问题。
>
>   ## 题目描述
>
>   N个偶像排成一列，他们来自M个不同的乐队。每个团队至少有一个偶像。
>
>   现在要求重新安排队列，使来自同一乐队的偶像连续的站在一起。重新安排的办法是，让若干偶像出列（剩下的偶像不动），然后让出列的偶像一个个归队到原来的空位，归队的位置任意。
>
>   请问最少让多少偶像出列？
>
>   ## 输入格式
>
>   第一行2个整数N，M。
>
>   接下来N个行，每行一个整数ai(1≤ai≤M)*a**i*(1≤*a**i*≤*M*)，表示队列中第i个偶像的团队编号。
>
>   ## 输出格式
>
>   一个整数，表示答案
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   12 4
>   1
>   3
>   2
>   4
>   2
>   1
>   2
>   3
>   1
>   1
>   3
>   4
>   ```
>
>   **输出 #1**复制
>
>   ```
>   7
>   ```
>
>   ## 说明/提示
>
>   【样例解释】
>
>   ```cpp
>   1  3   √
>   3  3
>   2  3   √
>   4  4
>   2  4   √
>   1  2   √
>   2  2
>   3  2   √
>   1  1
>   1  1
>   3  1   √
>   4  1   √
>   ```
>
>   【数据规模】
>
>   对于20%的数据，N≤20,M=2*N*≤20,*M*=2
>
>   对于40%的数据，N≤100,M≤4*N*≤100,*M*≤4
>
>   对于70%的数据，N≤2000,M≤10*N*≤2000,*M*≤10
>
>   对于全部数据，1≤N≤105,M≤201≤*N*≤105,*M*≤20

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

// 考虑枚举最终的排列 计算有多少个位值不同(需出列)

const int N = 1e5 + 10, M = (1 << 20) + 10;

int n, m;
int s[N][22], sz[M];
int f[M], len[M];

int main() {
    cin >> n >> m;
    
    for (int i = 1; i <= n; ++ i ) {
        int x;
        cin >> x;
        for (int j = 1; j <= m; ++ j )
            s[i][j] = s[i - 1][j] + (x == j);
        sz[x] ++ ;
    }
    
    memset(f, 0x3f, sizeof f);
    f[0] = 0; len[0] = 0;
    for (int i = 0; i < 1 << m; ++ i )
        for (int j = 0; j < m; ++ j )
            if (i >> j & 1) {
                int old = i ^ (1 << j);
                int l = len[old];
                int r = l + sz[j + 1];
                len[i] = r;
                
                int has = s[r][j + 1] - s[l][j + 1];
                f[i] = min(f[i], f[i ^ (1 << j)] + sz[j + 1] - has);
            }
        
    cout << f[(1 << m) - 1] << endl;
    
    return 0;
}
```



```python3

```

