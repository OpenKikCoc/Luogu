#  [集合](https://www.luogu.com.cn/problem/P1621)

## 题意

>   ## 题目描述
>
>   Caima 给你了所有 [a,b][*a*,*b*] 范围内的整数。一开始每个整数都属于各自的集合。每次你需要选择两个属于不同集合的整数，如果这两个整数拥有大于等于 p*p* 的公共质因数，那么把它们所在的集合合并。
>
>   重复如上操作，直到没有可以合并的集合为止。
>
>   现在 Caima 想知道，最后有多少个集合。
>
>   ## 输入格式
>
>   一行，共三个整数 a,b,p*a*,*b*,*p*，用空格隔开。
>
>   ## 输出格式
>
>   一个数，表示最终集合的个数。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   10 20 3
>   ```
>
>   **输出 #1**复制
>
>   ```
>   7
>   ```
>
>   ## 说明/提示
>
>   #### 样例 1 解释
>
>   对于样例给定的数据，最后有 {10,20,12,15,18},{13},{14},{16},{17},{19},{11}{10,20,12,15,18},{13},{14},{16},{17},{19},{11} 共 77 个集合，所以输出应该为 77。
>
>   #### 数据规模与约定
>
>   -   对于 80%80% 的数据，1≤a≤b≤1031≤*a*≤*b*≤103。
>   -   对于 100100 的数据，1≤a≤b≤105,2≤p≤b1≤*a*≤*b*≤105,2≤*p*≤*b*。

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

int a, b, p;
int pa[N];
bool st[N];

int find(int x) {
    if (pa[x] != x)
        pa[x] = find(pa[x]);
    return pa[x];
}

int main() {
    cin >> a >> b >> p;
    
    for (int i = a; i <= b; ++ i )
        pa[i] = i;
    
    // 每合并一次-1
    int res = b - a + 1;
    // 筛法
    for (int i = 2; i <= b; ++ i )
        if (!st[i]) {
            for (int j = i * 2; j <= b; j += i) {
                st[j] = true;
                
                // i >= p 才合并    合并需要 j - i >= a
                if (i >= p && j - i >= a) {
                    int fa = find(j), fb = find(j - i);
                    if (fa != fb) {
                        pa[fa] = fb;
                        res -- ;
                    }
                }
            }
        }
    cout << res << endl;
    
    return 0;
}
```



```python3

```

