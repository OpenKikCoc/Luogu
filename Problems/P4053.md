#  [[JSOI2007]建筑抢修](https://www.luogu.com.cn/problem/P4053)

## 题意

>   ## 题目描述
>
>   小刚在玩JSOI提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T部落消灭了所有z部落的入侵者。但是T部落的基地里已经有N个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。
>
>   ## 输入格式
>
>   第一行是一个整数N，接下来N行每行两个整数T1,T2描述一个建筑：修理这个建筑需要T1秒，如果在T2秒之内还没有修理完成，这个建筑就报废了。
>
>   ## 输出格式
>
>   输出一个整数S，表示最多可以抢修S个建筑.
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   4
>   100 200
>   200 1300
>   1000 1250
>   2000 3200
>   ```
>
>   **输出 #1**复制
>
>   ```
>   3
>   ```
>
>   ## 说明/提示
>
>   N < 150,000; T1 < T2 < maxlongint

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

// 核心：贪心策略
// 先按 t 贪心，中途再更改
// 1. 按 t 从小到大排序之后，开始轮流遍历每个建筑
// 2. 如果中途某个建筑 i 无法在 t_i 的时间内修复，
//    那么在先前选择修复的建筑中拿出 w_j 最大的 j 号建筑
//    若 w_i < w_j ，则放弃 j 转而修 i。

const int N = 150010;

int n, T;  // T指遍历时经过了多久时间
struct node {
    int w, t;
} a[N];
priority_queue<int> Q;  //优先队列

bool cmp(node x, node y) {
    return x.t < y.t;  //按t从小到大排序
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d%d", &a[i].w, &a[i].t);
    sort(a + 1, a + n + 1, cmp);

    int res = 0;
    for (int i = 1; i <= n; i++)
        //如果无法修复此楼
        if (T + a[i].w > a[i].t) {
            // ai < aj
            if (a[i].w < Q.top()) {
                //注意这里要减掉
                T -= Q.top();
                Q.pop();
                Q.push(a[i].w);
                T += a[i].w;
            }
        } else {
            Q.push(a[i].w);
            res++;
            T += a[i].w;
        }

    printf("%d\n", res);

    return 0;
}
```



```python3

```

