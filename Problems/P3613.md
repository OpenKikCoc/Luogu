#  [【深基15.例2】寄包柜](https://www.luogu.com.cn/problem/P3613)

## 题意

>   ## 题目描述
>
>   超市里有 n(n≤105)*n*(*n*≤105) 个寄包柜。每个寄包柜格子数量不一，第 i*i* 个寄包柜有 ai(ai≤105)*a**i*(*a**i*≤105) 个格子，不过我们并不知道各个 ai*a**i* 的值。对于每个寄包柜，格子编号从 1 开始，一直到 ai*a**i*。现在有 q(q≤105)*q*(*q*≤105) 次操作：
>
>   -   `1 i j k`：在第 i*i* 个柜子的第 j*j* 个格子存入物品 k(0≤k≤109)*k*(0≤*k*≤109)。当 k=0*k*=0 时说明清空该格子。
>   -   `2 i j`：查询第 i*i* 个柜子的第 j*j* 个格子中的物品是什么，保证查询的柜子有存过东西。
>
>   已知超市里共计不会超过 107107 个寄包格子，ai*a**i* 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。当然也有可能某些寄包柜中一个格子都没有。
>
>   ## 输入格式
>
>   第一行 2 个整数 n 和 q，寄包柜个数和询问次数。
>
>   接下来 q 个整数，表示一次操作。
>
>   ## 输出格式
>
>   对于查询操作时，输出答案。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   5 4
>   1 3 10000 114514
>   1 1 1 1
>   2 3 10000
>   2 1 1
>   ```
>
>   **输出 #1**复制
>
>   ```
>   114514
>   1
>   ```

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;

int n, q;
unordered_map<int, int> g[N];

int main() {
    cin >> n >> q;
    
    while (q -- ) {
        int t;
        cin >> t;
        if (t == 1) {
            int i, j, k;
            cin >> i >> j >> k;
            g[i][j] = k;
        } else {
            int i, j;
            cin >> i >> j;
            cout << g[i][j] << endl;
        }
    }
    return 0;
}
```



```python3

```

