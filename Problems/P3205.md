#  [[HNOI2010]合唱队](https://www.luogu.com.cn/problem/P3205)

## 题意

>   ## 题目描述
>
>   为了在即将到来的晚会上有更好的演出效果，作为 AAA 合唱队负责人的小 A 需要将合唱队的人根据他们的身高排出一个队形。假定合唱队一共 n*n* 个人，第 i*i* 个人的身高为 hi*h**i* 米（1000≤hi≤20001000≤*h**i*≤2000），并已知任何两个人的身高都不同。假定最终排出的队形是 A*A* 个人站成一排，为了简化问题，小 A 想出了如下排队的方式：他让所有的人先按任意顺序站成一个初始队形，然后从左到右按以下原则依次将每个人插入最终棑排出的队形中：
>
>   -   第一个人直接插入空的当前队形中。
>   -   对从第二个人开始的每个人，如果他比前面那个人高（h*h* 较大），那么将他插入当前队形的最右边。如果他比前面那个人矮（h*h* 较小），那么将他插入当前队形的最左边。
>
>   当 n*n* 个人全部插入当前队形后便获得最终排出的队形。
>
>   例如，有 66 个人站成一个初始队形，身高依次为 1850,1900,1700,1650,1800,17501850,1900,1700,1650,1800,1750，
>   那么小 A 会按以下步骤获得最终排出的队形：
>
>   -   18501850。
>   -   1850,19001850,1900，因为 1900>18501900>1850。
>   -   1700,1850,19001700,1850,1900，因为 1700<19001700<1900。
>   -   1650,1700,1850,19001650,1700,1850,1900，因为 1650<17001650<1700。
>   -   1650,1700,1850,1900,18001650,1700,1850,1900,1800，因为 1800>16501800>1650。
>   -   1750,1650,1700,1850,1900,18001750,1650,1700,1850,1900,1800，因为 1750<18001750<1800。
>
>   因此，最终排出的队形是 1750,1650,1700,1850,1900,18001750,1650,1700,1850,1900,1800。
>
>   小 A 心中有一个理想队形，他想知道多少种初始队形可以获得理想的队形。
>
>   请求出答案对 1965082719650827 取模的值。
>
>   ## 输入格式
>
>   第一行一个整数 n*n*。
>   第二行 n*n* 个整数，表示小 A 心中的理想队形。
>
>   ## 输出格式
>
>   输出一行一个整数，表示答案  19650827mod19650827 的值。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   4
>   1701 1702 1703 1704
>   ```
>
>   **输出 #1**复制
>
>   ```
>   8
>   ```
>
>   ## 说明/提示
>
>   对于 30%30% 的数据，n≤100*n*≤100。
>   对于 100%100% 的数据，n≤1000*n*≤1000，1000≤hi≤20001000≤*h**i*​≤2000。

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

// 显然区间dp 如下实现即可
//
// 对于子区间长度为1的情况写了好几个if判断 不够优雅
// 实际上只有一个人的方案只有一种 可以直接按照默认在左侧进来
// 即 初始化 f[i][i][0] = 1, f[i][i][1] = 0;即可 略

const int N = 1010, MOD = 19650827;

int n;
int a[N];
int f[N][N][2];

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++ i )
        cin >> a[i];
    
    for (int i = 1; i <= n; ++ i )
        f[i][i][0] = f[i][i][1] = 1;
    
    for (int len = 2; len <= n; ++ len )
        for (int l = 1; l + len - 1 <= n; ++ l ) {
            int r = l + len - 1;
            
            {
                int v = a[l];
                int tl = l + 1, tr = r, vl = 0, vr = 0;
                if (v < a[tl])
                    vl = f[tl][tr][0];
                if (v < a[tr])
                    vr = f[tl][tr][1];
                if (tl == tr)
                    f[l][r][0] = (f[l][r][0] + vl) % MOD;
                else
                    f[l][r][0] = (f[l][r][0] + (vl + vr) % MOD) % MOD;
            }
            {
                int v = a[r];
                int tl = l, tr = r - 1, vl = 0, vr = 0;
                if (v > a[tl])
                    vl = f[tl][tr][0];
                if (v > a[tr])
                    vr = f[tl][tr][1];
                if (tl == tr)
                    f[l][r][1] = (f[l][r][1] + vl) % MOD;
                else
                    f[l][r][1] = (f[l][r][1] + (vl + vr) % MOD) % MOD;
            }
        }
        
    cout << (f[1][n][0] + f[1][n][1]) % MOD << endl;
    
    return 0;
}
```



```python3

```

