#  [[AHOI2018初中组]分组](https://www.luogu.com.cn/problem/P4447)

## 题意

>   ## 题目描述
>
>   小可可的学校信息组总共有n 个队员，每个人都有一个实力值a[i]*a*[*i*]。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的n*n*个队员分成若干个小组去参加这场比赛。
>
>   但是每个队员都不会愿意与实力跟自己过于悬殊的队员组队，于是要求分成的每个小组的队员实力值连续，同时，一个队不需要两个实力相同的选手。举个例子：[1,2,3,4,5][1,2,3,4,5]是合法的分组方案，因为实力值连续；[1,2,3,5][1,2,3,5]不是合法的分组方案，因为实力值不连续；[0,1,1,2][0,1,1,2]同样不是合法的分组方案，因为出现了两个实力值为1 的选手。
>
>   如果有小组内人数太少，就会因为时间不够而无法获得高分，于是小可可想让你给出一个合法的分组方案，满足所有人都恰好分到一个小组，使得人数最少的组人数最多，输出人数最少的组人数的最大值。
>
>   注意：实力值可能是负数，分组的数量没有限制。
>
>   ## 输入格式
>
>   输入有两行：
>
>   第一行一个正整数n，表示队员数量。
>   第二行有n 个整数，第i 个整数a[i]表示第i 个队员的实力。
>
>   ## 输出格式
>
>   输出一行，包括一个正整数，表示人数最少的组的人数最大值。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   7
>   4 5 2 3 -4 -3 -5
>   ```
>
>   **输出 #1**复制
>
>   ```
>   3
>   ```
>
>   ## 说明/提示
>
>   【样例解释】 分为2 组，一组的队员实力值是4,5,2,34,5,2,3，一组是−4,−3,−5−4,−3,−5，其中最小的组人数为3，可以发现没有比3 更优的分法了。
>
>   【数据范围】
>
>   对于100%的数据满足：1≤n≤1000001≤*n*≤100000，∣a[i]∣≤109∣*a*[*i*]∣≤109。
>
>   本题共10 个测试点，编号为1~10，每个测试点额外保证如下：
>
>   1~2 n≤6,1≤a[i]≤100*n*≤6,1≤*a*[*i*]≤100
>   3~4 n≤1000,1≤a[i]≤105*n*≤1000,1≤*a*[*i*]≤105 且a[i]互不相同
>   5~6 n≤100000,a[i]*n*≤100000,*a*[*i*]互不相同
>   7~8 n≤100000,1≤a[i]≤105*n*≤100000,1≤*a*[*i*]≤105
>   9~10 n≤100000,∣a[i]∣≤109*n*≤100000,∣*a*[*i*]∣≤109

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

using PII = pair<int, int>;
#define x first
#define y second
const int N = 1e5 + 10;

int n;
unordered_map<int, int> cnt;
vector<PII> ve;

int main() {
    cin >> n;
    for (int i = 0; i < n; ++ i ) {
        int v;
        cin >> v;
        cnt[v] ++ ;
    }
    
    for (auto [k, v] : cnt)
        ve.push_back({k, v});
    sort(ve.begin(), ve.end());
    
    int res = 2e9;
    int m = ve.size();
    for (int i = 0; i < m; ++ i ) {
        // 先消耗一个连续上升区间
        ve[i].y -- ;
        int j = i + 1;
        while (j < m && ve[j].x == ve[j - 1].x + 1 && ve[j].y > ve[j - 1].y)
            ve[j].y -- , j ++ ;
        
        // [l, j - 1]
        int len = j - i;
        if (len < res)
            res = len;

        int k = i;
        while (k < m && ve[k].y == 0)
            k ++ ;
        i = k - 1;
    }
    cout << res << endl;
    
    return 0;
}
```



```python3

```

