#  [[ZJOI2006]三色二叉树](https://www.luogu.com.cn/problem/P2585)

## 题意

>   ## 题目描述
>
>   一棵二叉树可以按照如下规则表示成一个由 00、11、22 组成的字符序列，我们称之为“二叉树序列 S*S*”：
>
>   S={0表示该树没有子节点1S1表示该树有一个节点，S1为其子树的二叉树序列2S1S2表示该树由两个子节点，S1和S2分别表示其两个子树的二叉树序列*S*=⎩⎪⎪⎨⎪⎪⎧01*S*12*S*1*S*2表示该树没有子节点表示该树有一个节点，*S*1为其子树的二叉树序列表示该树由两个子节点，*S*1和*S*2分别表示其两个子树的二叉树序列
>
>   例如，下图所表示的二叉树可以用二叉树序列 S=21200110*S*=21200110 来表示。
>
>   ![haha.png](https://i.loli.net/2020/04/27/Ijw8ZEWCKH2rtJG.png)
>
>   你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点的颜色也必须不同。给定一颗二叉树的二叉树序列，请求出这棵树中**最多和最少**有多少个点能够被染成绿色。
>
>   ## 输入格式
>
>   输入只有一行一个字符串 s*s*，表示二叉树序列。
>
>   ## 输出格式
>
>   输出只有一行，包含两个数，依次表示最多和最少有多少个点能够被染成绿色。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   1122002010
>   ```
>
>   **输出 #1**复制
>
>   ```
>   5 2
>   ```
>
>   ## 说明/提示
>
>   #### 数据规模与约定
>
>   对于全部的测试点，保证 1≤∣s∣≤5×1051≤∣*s*∣≤5×105，s*s* 中只含字符 `0` `1` `2`。

## 题解



```c++
#include <cstdio>
#include <cstring>
#include <iostream>
using namespace std;
const int N = 500050;
char s[N];
int f[N][3], g[N][3], cnt;

int res = 1;

void dfs(int x) {
    if (s[x] == '0') {  //叶节点
        g[x][0] = f[x][0] = 1;
        return;
    }
    dfs(++cnt);
    // 左儿子编号为x+1
    if (s[x] == '1') {  //一个儿子
        f[x][0] = max(f[x + 1][1], f[x + 1][2]) + 1;
        f[x][1] = max(f[x + 1][0], f[x + 1][2]);
        f[x][2] = max(f[x + 1][0], f[x + 1][1]);

        // 上方代码完全是复制一遍到下面
        g[x][0] = min(g[x + 1][1], g[x + 1][2]) + 1;
        g[x][1] = min(g[x + 1][0], g[x + 1][2]);
        g[x][2] = min(g[x + 1][0], g[x + 1][1]);
    } else {
        // 右儿子编号为k
        int k = ++cnt;
        dfs(k);
        f[x][0] = max(f[x + 1][1] + f[k][2], f[x + 1][2] + f[k][1]) + 1;
        f[x][1] = max(f[x + 1][0] + f[k][2], f[x + 1][2] + f[k][0]);
        f[x][2] = max(f[x + 1][0] + f[k][1], f[x + 1][1] + f[k][0]);

        g[x][0] = min(g[x + 1][1] + g[k][2], g[x + 1][2] + g[k][1]) + 1;
        g[x][1] = min(g[x + 1][0] + g[k][2], g[x + 1][2] + g[k][0]);
        g[x][2] = min(g[x + 1][0] + g[k][1], g[x + 1][1] + g[k][0]);
    }
    res = max(res, f[x][0]);
}
int main() {
    scanf("%s", s + 1);
    dfs(++cnt);
    cout << res << ' ' << min(g[1][0], min(g[1][1], g[1][2])) << endl;

    return 0;
}
```



```python3

```

