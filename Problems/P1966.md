#  [[NOIP2013 提高组] 火柴排队](https://www.luogu.com.cn/problem/P1966)

## 题意

>   ## 题目描述
>
>   涵涵有两盒火柴，每盒装有 n*n* 根火柴，每根火柴都有一个高度。 现在将每盒中的火柴各自排成一列， 同一列火柴的高度互不相同， 两列火柴之间的距离定义为：∑(ai−bi)2∑(*a**i*−*b**i*)2
>
>   其中 ai*a**i* 表示第一列火柴中第 i*i* 个火柴的高度，bi*b**i* 表示第二列火柴中第 i*i* 个火柴的高度。
>
>   每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 108−3108−3 取模的结果。
>
>   ## 输入格式
>
>   共三行，第一行包含一个整数 n*n*，表示每盒中火柴的数目。
>
>   第二行有 n*n* 个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。
>
>   第三行有 n*n* 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。
>
>   ## 输出格式
>
>   一个整数，表示最少交换次数对 108−3108−3 取模的结果。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   4
>   2 3 1 4
>   3 2 1 4
>   ```
>
>   **输出 #1**复制
>
>   ```
>   1
>   ```
>
>   **输入 #2**复制
>
>   ```
>   4
>   1 3 4 2
>   1 7 2 4
>   ```
>
>   **输出 #2**复制
>
>   ```
>   2
>   ```
>
>   ## 说明/提示
>
>   【输入输出样例说明一】
>
>   最小距离是00，最少需要交换 11 次，比如：交换第 11列的前22 根火柴或者交换第 22 列的前 22根火柴。
>
>   【输入输出样例说明二】
>
>   最小距离是 1010，最少需要交换 22 次，比如：交换第 11 列的中间 22 根火柴的位置，再交换第 22 列中后 22 根火柴的位置。
>
>   【数据范围】
>
>   对于 10%10% 的数据， 1≤n≤101≤*n*≤10；
>
>   对于 30%30% 的数据，1≤n≤1001≤*n*≤100；
>
>   对于 60%60% 的数据，1≤n≤1031≤*n*≤103；
>
>   对于 100%100% 的数据，1≤n≤1051≤*n*≤105，0≤0≤ 火柴高度 <231<231。

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10, MOD = 1e8 - 3;

int n;
int x[N], t[N];
struct Node {
    int x, id;
} a[N], b[N];

int merge(int l, int r) {
    if (l >= r)
        return 0;
    
    int m = l + r >> 1;
    int ret = (merge(l, m) + merge(m + 1, r)) % MOD;
    int i = l, j = m + 1, k = 0;
    while (i <= m && j <= r)
        if (x[i] <= x[j])
            t[k ++ ] = x[i ++ ];
        else
            ret = (ret + m + 1 - i) % MOD, t[k ++ ]= x[j ++ ];
    
    while (i <= m)
        t[k ++ ] = x[i ++ ];
    while (j <= r)
        t[k ++ ] = x[j ++ ];

    for (int i = l, j = 0; i <= r; ++ i , ++ j )
        x[i] = t[j];
    return ret;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++ i )
        cin >> a[i].x, a[i].id = i;
    for (int i = 0; i < n; ++ i )
        cin >> b[i].x, b[i].id = i;
    
    auto cmp = [](const Node & a, const Node & b) -> bool {
        return a.x < b.x;
    };
    sort(a, a + n, cmp);
    sort(b, b + n, cmp);
    
    for (int i = 0; i < n; ++ i )
        x[a[i].id] = b[i].id;
    
    cout << merge(0, n - 1) << endl;
    
    return 0;
}
```



```python3

```

