#  [[NOI2015] 程序自动分析](https://www.luogu.com.cn/problem/P1955)

## 题意

>   ## 题目描述
>
>   在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。
>
>   考虑一个约束满足问题的简化版本：假设 x1,x2,x3,⋯*x*1,*x*2,*x*3,⋯ 代表程序中出现的变量，给定 n*n* 个形如 xi=xj*x**i*=*x**j* 或 xi≠xj*x**i*=*x**j* 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1*x*1=*x*2,*x*2=*x*3,*x*3=*x*4,*x*4=*x*1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。
>
>   现在给出一些约束满足问题，请分别对它们进行判定。
>
>   ## 输入格式
>
>   输入的第一行包含一个正整数 t*t*，表示需要判定的问题个数。注意这些问题之间是相互独立的。
>
>   对于每个问题，包含若干行：
>
>   第一行包含一个正整数 n*n*，表示该问题中需要被满足的约束条件个数。接下来 n*n* 行，每行包括三个整数 i,j,e*i*,*j*,*e*，描述一个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 e=1*e*=1，则该约束条件为 xi=xj*x**i*=*x**j*。若e=0*e*=0，则该约束条件为 xi≠xj*x**i*=*x**j*。
>
>   ## 输出格式
>
>   输出包括 t*t* 行。
>
>   输出文件的第 k*k* 行输出一个字符串 `YES` 或者 `NO`（字母全部大写），`YES` 表示输入中的第 k*k* 个问题判定为可以被满足，`NO` 表示不可被满足。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   2
>   2
>   1 2 1
>   1 2 0
>   2
>   1 2 1
>   2 1 1
>   ```
>
>   **输出 #1**复制
>
>   ```
>   NO
>   YES
>   ```
>
>   **输入 #2**复制
>
>   ```
>   2
>   3
>   1 2 1
>   2 3 1
>   3 1 1
>   4
>   1 2 1
>   2 3 1
>   3 4 1
>   1 4 0
>   ```
>
>   **输出 #2**复制
>
>   ```
>   YES
>   NO
>   ```
>
>   ## 说明/提示
>
>   【样例解释1】
>
>   在第一个问题中，约束条件为：x1=x2,x1≠x2*x*1=*x*2,*x*1=*x*2。这两个约束条件互相矛盾，因此不可被同时满足。
>
>   在第二个问题中，约束条件为：x1=x2,x1=x2*x*1=*x*2,*x*1=*x*2。这两个约束条件是等价的，可以被同时满足。
>
>   【样例说明2】
>
>   在第一个问题中，约束条件有三个：x1=x2,x2=x3,x3=x1*x*1=*x*2,*x*2=*x*3,*x*3=*x*1。只需赋值使得 x1=x2=x3*x*1=*x*2=*x*3，即可同时满足所有的约束条件。
>
>   在第二个问题中，约束条件有四个：x1=x2,x2=x3,x3=x4,x4≠x1*x*1=*x*2,*x*2=*x*3,*x*3=*x*4,*x*4=*x*1。由前三个约束条件可以推出 x1=x2=x3=x4*x*1=*x*2=*x*3=*x*4，然而最后一个约束条件却要求 x1≠x4*x*1=*x*4，因此不可被满足。
>
>   【数据范围】
>
>   ![img](https://cdn.luogu.com.cn/upload/pic/1503.png)
>
>   注：实际上 n≤106*n*≤106 。

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;

struct Query {
    int x, y, e;
} qs[N];

int n, m;
int p[N];
unordered_map<int, int> S;

int get(int x) {
    if (S.count(x) == 0)
        S[x] = ++ n ;
    return S[x];
}

int find(int x) {
    if (p[x] != x)
        p[x] = find(p[x]);
    return p[x];
}

int main() {
    int t;
    cin >> t;
    while (t -- ) {
        n = 0;
        S.clear();
        
        cin >> m;
        for (int i = 0; i < m; ++ i ) {
            int x, y, e;
            cin >> x >> y >> e;
            qs[i] = {get(x), get(y), e};
        }
        
        for (int i = 1; i <= n; ++ i )
            p[i] = i;
        
        for (int i = 0; i < m; ++ i )
            if (qs[i].e == 1)
                p[find(qs[i].x)] = p[find(qs[i].y)];
        
        bool has_conflict = false;
        for (int i = 0; i < m; ++ i )
            if (qs[i].e == 0) {
                int pa = find(qs[i].x), pb = find(qs[i].y);
                if (pa == pb) {
                    has_conflict = true;
                    break;
                }
            }
        cout << (has_conflict ? "NO" : "YES") << endl;
    }
    return 0;
}
```



```python3

```

