#  [地毯](https://www.luogu.com.cn/problem/P3397)

## 题意

>   ## 题目背景
>
>   此题约为NOIP提高组Day2T1难度。
>
>   ## 题目描述
>
>   在 n×n*n*×*n* 的格子上有 m*m* 个地毯。
>
>   给出这些地毯的信息，问每个点被多少个地毯覆盖。
>
>   ## 输入格式
>
>   第一行，两个正整数 n,m*n*,*m*。意义如题所述。
>
>   接下来 m*m* 行，每行两个坐标 (x1,y1)(*x*1,*y*1) 和 (x2,y2)(*x*2,*y*2)，代表一块地毯，左上角是 (x1,y1)(*x*1,*y*1)，右下角是 (x2,y2)(*x*2,*y*2)。
>
>   ## 输出格式
>
>   输出 n*n* 行，每行 n*n* 个正整数。
>
>   第 i*i* 行第 j*j* 列的正整数表示 (i,j)(*i*,*j*) 这个格子被多少个地毯覆盖。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   5 3
>   2 2 3 3
>   3 3 5 5
>   1 2 1 4
>   ```
>
>   **输出 #1**复制
>
>   ```
>   0 1 1 1 0
>   0 1 1 0 0
>   0 1 2 1 1
>   0 0 1 1 1
>   0 0 1 1 1
>   ```
>
>   ## 说明/提示
>
>   ### 样例解释
>
>   覆盖第一个地毯后：
>
>   |  00  |  00  |  00  |  00  |  00  |
>   | :--: | :--: | :--: | :--: | :--: |
>   |  00  |  11  |  11  |  00  |  00  |
>   |  00  |  11  |  11  |  00  |  00  |
>   |  00  |  00  |  00  |  00  |  00  |
>   |  00  |  00  |  00  |  00  |  00  |
>
>   覆盖第一、二个地毯后：
>
>   |  00  |  00  |  00  |  00  |  00  |
>   | :--: | :--: | :--: | :--: | :--: |
>   |  00  |  11  |  11  |  00  |  00  |
>   |  00  |  11  |  22  |  11  |  11  |
>   |  00  |  00  |  11  |  11  |  11  |
>   |  00  |  00  |  11  |  11  |  11  |
>
>   覆盖所有地毯后：
>
>   |  00  |  11  |  11  |  11  |  00  |
>   | :--: | :--: | :--: | :--: | :--: |
>   |  00  |  11  |  11  |  00  |  00  |
>   |  00  |  11  |  22  |  11  |  11  |
>   |  00  |  00  |  11  |  11  |  11  |
>   |  00  |  00  |  11  |  11  |  11  |
>
>   ------
>
>   ### 数据范围
>
>   对于 20%20% 的数据，有 n≤50*n*≤50，m≤100*m*≤100。
>
>   对于 100%100% 的数据，有 n,m≤1000*n*,*m*≤1000。

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;

int n, m;
int d[N][N];

void insert(int x1, int y1, int x2, int y2, int c) {
    d[x1][y1] += c;
    d[x2 + 1][y1] -= c;
    d[x1][y2 + 1] -= c;
    d[x2 + 1][y2 + 1] += c;
}

int main() {
    cin >> n >> m;
    while (m -- ) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        insert(x1, y1, x2, y2, 1);
    }
    
    for (int i = 1; i <= n; ++ i )
        for (int j = 1; j <= n; ++ j )
            d[i][j] += d[i - 1][j] + d[i][j - 1] - d[i - 1][j - 1];
    
    for (int i = 1; i <= n; ++ i ) {
        for (int j = 1; j <= n; ++ j )
            cout << d[i][j] << ' ';
        cout << endl;
    }
    return 0;
}
```



```python3

```

