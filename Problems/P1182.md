#  [数列分段 Section II](https://www.luogu.com.cn/problem/P1182)

## 题意

>   ## 题目描述
>
>   对于给定的一个长度为N的正整数数列 A1∼N*A*1∼*N*，现要将其分成 M*M*（M≤N*M*≤*N*）段，并要求每段连续，且每段和的最大值最小。
>
>   关于最大值最小：
>
>   例如一数列 4 2 4 5 14 2 4 5 1 要分成 33 段。
>
>   将其如下分段：
>
>   [4 2][4 5][1][4 2][4 5][1]
>
>   第一段和为 66，第 22 段和为 99，第 33 段和为 11，和最大值为 99。
>
>   将其如下分段：
>
>   [4][2 4][5 1][4][2 4][5 1]
>
>   第一段和为 44，第 22 段和为 66，第 33 段和为 66，和最大值为 66。
>
>   并且无论如何分段，最大值不会小于 66。
>
>   所以可以得到要将数列 4 2 4 5 14 2 4 5 1 要分成 33 段，每段和的最大值最小为 66。
>
>   ## 输入格式
>
>   第 11 行包含两个正整数 N,M*N*,*M*。
>
>   第 22 行包含 N*N* 个空格隔开的非负整数 Ai*A**i*，含义如题目所述。
>
>   ## 输出格式
>
>   一个正整数，即每段和最大值最小为多少。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   5 3
>   4 2 4 5 1
>   ```
>
>   **输出 #1**复制
>
>   ```
>   6
>   ```
>
>   ## 说明/提示
>
>   对于 20%20% 的数据，N≤10*N*≤10。
>
>   对于 40%40% 的数据，N≤1000*N*≤1000。
>
>   对于 100%100% 的数据，1≤N≤1051≤*N*≤105，M≤N*M*≤*N*，Ai<108*A**i*<108， 答案不超过 109109。

## 题解



```c++
#include <bits/stdc++.h>
using namespace std;

using LL = long long;
const int N = 1e5 + 10;

LL n, m, s;
int a[N];

// mid 为一段可以达到的最大值
// illegal
bool check(LL mid) {
    LL c = 0;
    for (int i = 0; i < n; ++ i ) {
        if (a[i] > mid)
            return true;
        
        int j = i;
        LL sum = 0;
        while (j < n && sum + a[j] <= mid)
            sum += a[j ++ ];
        // [i, j - 1]
        c ++ ;
        i = j - 1;
    }
    // cout << "mid = " << mid << " c = " << c << endl;
    return c > m;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; ++ i )
        cin >> a[i], s += a[i];
    
    LL l = 0, r = s;
    while (l < r) {
        LL mid = l + r >> 1;
        if (check(mid))
            l = mid + 1;
        else
            r = mid;
    }
    cout << l << endl;
    
    return 0;
}
```



```python3

```

