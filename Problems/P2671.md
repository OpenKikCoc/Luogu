#  [[NOIP2015 普及组] 求和](https://www.luogu.com.cn/problem/P2671)

## 题意

>   ## 题目描述
>
>   一条狭长的纸带被均匀划分出了n*n*个格子，格子编号从11到n*n*。每个格子上都染了一种颜色color_i*c**o**l**o**r*_*i*用[1,m][1,*m*]当中的一个整数表示），并且写了一个数字number_i*n**u**m**b**e**r*_*i*。
>
>   ![img](https://cdn.luogu.com.cn/upload/pic/1829.png)
>
>   定义一种特殊的三元组：(x,y,z)(*x*,*y*,*z*)，其中x,y,z*x*,*y*,*z*都代表纸带上格子的编号，这里的三元组要求满足以下两个条件：
>
>   1.  xyz*x**y**z*是整数,x<y<z,y−x=z−y*x*<*y*<*z*,*y*−*x*=*z*−*y*
>   2.  colorx=colorz*c**o**l**o**r**x*=*c**o**l**o**r**z*
>
>   满足上述条件的三元组的分数规定为(x+z)×(number_x+number_z)(*x*+*z*)×(*n**u**m**b**e**r*_*x*+*n**u**m**b**e**r*_*z*)。整个纸带的分数规定为所有满足条件的三元组的分数的和。这个分数可能会很大，你只要输出整个纸带的分数除以10,00710,007所得的余数即可。
>
>   ## 输入格式
>
>   第一行是用一个空格隔开的两个正整数n*n*和m,n*m*,*n*表纸带上格子的个数，m*m*表纸带上颜色的种类数。
>
>   第二行有n*n*用空格隔开的正整数，第i*i*数字number*n**u**m**b**e**r*表纸带上编号为i*i*格子上面写的数字。
>
>   第三行有n*n*用空格隔开的正整数，第i*i*数字color*c**o**l**o**r*表纸带上编号为i*i*格子染的颜色。
>
>   ## 输出格式
>
>   一个整数，表示所求的纸带分数除以1000710007所得的余数。
>
>   ## 输入输出样例
>
>   **输入 #1**复制
>
>   ```
>   6 2
>   5 5 3 2 2 2
>   2 2 1 1 2 1
>   ```
>
>   **输出 #1**复制
>
>   ```
>   82
>   ```
>
>   **输入 #2**复制
>
>   ```
>   15 4
>   5 10 8 2 2 2 9 9 7 7 5 6 4 2 4
>   2 2 3 3 4 3 3 2 4 4 4 4 1 1 1
>   ```
>
>   **输出 #2**复制
>
>   ```
>   1388
>   ```
>
>   ## 说明/提示
>
>   【输入输出样例 1 说明】
>
>   纸带如题目描述中的图所示。
>
>   所有满足条件的三元组为： (1,3,5),(4,5,6)(1,3,5),(4,5,6)。
>
>   所以纸带的分数为(1+5)×(5+2)+(4+6)×(2+2)=42+40=82(1+5)×(5+2)+(4+6)×(2+2)=42+40=82。
>
>   对于第 11 组至第 22 组数据， 1≤n≤100,1≤m≤51≤*n*≤100,1≤*m*≤5；
>
>   对于第33 组至第 44 组数据， 1≤n≤3000,1≤m≤1001≤*n*≤3000,1≤*m*≤100；
>
>   对于第 55 组至第66组数据， 1≤n≤100000,1≤m≤1000001≤*n*≤100000,1≤*m*≤100000，且不存在出现次数超过2020的颜色；
>
>   对 于 全 部 1010 组 数 据 ， 1≤n≤100000,1≤m≤100000,1≤color_i≤m,1≤number_i≤1000001≤*n*≤100000,1≤*m*≤100000,1≤*c**o**l**o**r*_*i*≤*m*,1≤*n**u**m**b**e**r*_*i*≤100000

## 题解


核心：奇偶性

易于想到x z颜色相同且同奇偶，且每个三元组其实是 `中间坐标的两倍*左右和`

显然有O(n^2)做法但会超时

**考虑先按颜色分组，由【同奇偶】的性质每组内再按奇偶分组**

考虑最终分组后的单个组（总个数为k），组内需如下统计：

```c++
[第i个数的下标用x[i]指代 值用y[i]指代]
for (int i = 0; i < k; ++ i )
    for (int j = i + 1; j < k; ++ j )
        t += (x[i] + x[j]) * (y[i] + y[j]);
```

转化（提取x[i]）：

```
t = x[1] * ((y[1] + y[2]) + (y[1] + y[3]) + (y[1] + y[4]) + ... + (y[1] + y[k]))
  + x[2] * ((y[2] + y[1]) + (y[2] + y[3]) + (y[2] + y[4]) + ... + (y[2] + y[k]))
  + ...
  + x[k-1] * ((y[k-1] + y[1]) +                                 + (y[k-1] + y[k]))
  + x[k] * ((y[k] + y[1]) +                                     + (y[k] + y[k-1]))
```

也即（注意k-2）：

```
t = x[1] * (y[1] * (k-2) + y[1] + y[2] + ... + y[k])
  + x[2] * (y[2] * (k-2) + y[1] + y[2] + ... + y[k])
  + ...
  + x[k-1] * (y[k-1] * (k-2) + y[1] + y[2] + ... + y[k])
  + x[k] * (y[k] * (k-2) + y[1] + y[2] + ... + y[k])
```

则 可线性求解

进一步提取公因式：

```
t = (k-2) * sum{(x[i] * y[i])} + sum{yi} * sum{xi}
```

```
因为 sum{(x[i] * y[i])} 的部分只与第i项相关 所以可以
以 for (int i = 1; i <= n; ++ i ) 的形式单独累加每一个
因而有luogu大多数题解的代码实现如：
https://www.luogu.com.cn/problem/solution/P2671
```

```c++
#include <bits/stdc++.h>
using namespace std;

using LL = long long;
const int N = 1e5 + 10, MOD = 10007;

int n, m;
int a[N], c[N];
vector<int> g[N][2];  // 分组

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    
    cin >> n >> m;
    for (int i = 1; i <= n; ++ i )
        cin >> a[i];
    for (int i = 1; i <= n; ++ i )
        cin >> c[i], g[c[i]][i % 2].push_back(i);
    
    int res = 0;
    for (int i = 1; i <= m; ++ i )
        for (int j = 0; j < 2; ++ j ) {
            int sz = g[i][j].size();
            int s = 0, sx = 0, sy = 0;
            for (int k = 0; k < sz; ++ k ) {
                int id = g[i][j][k];
                s = (s + (LL)id * a[id] % MOD) % MOD;
                sx = (sx + a[id]) % MOD;
                sy = (sy + id) % MOD;
            }
            res = (res + (LL)(sz - 2) * s % MOD + sx * sy % MOD) % MOD;
        }
    cout << res << endl;
    
    return 0;
}
```



```python3

```

